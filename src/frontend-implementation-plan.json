{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Replace unbounded server case fetch with paginated loading and unblock local rendering after case creation",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Replace frontend server-cases query to use paginated getSurgeryCases(start, limit) aggregation (no getAllSurgeryCases) with bounded page size and surfaced errors.",
      "acceptanceCriteria": [
        "On production, loading the case list does not call `getAllSurgeryCases()`.",
        "The app fetches server cases via repeated calls to `getSurgeryCases(start, limit)` with a bounded page size (<= 100).",
        "If the backend rejects/traps during any page fetch, the error is surfaced to the UI (not an indefinite spinner), and the raw error is still logged to the console for debugging.",
        "After creating a case, the case list screen can render without being blocked by a failing/unavailable server-cases fetch."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Update the server-cases React Query hook to stop calling actor.getAllSurgeryCases() and instead aggregate pages from actor.getSurgeryCases(start, limit) using a bounded page size (<= 100) until completion. Ensure failures are not retried indefinitely (keep retry disabled), log the raw error to console, and throw a user-facing Error so the UI can render an error state. Keep the queryKey as ['serverSurgeryCases'] so existing invalidations continue to work."
        },
        {
          "path": "frontend/src/hooks/useCasesStore.ts",
          "operation": "modify",
          "description": "Update store wiring to consume the updated paginated server-cases hook (same queryKey) and to avoid gating merged case computation on server loading. Ensure merged cases can be computed with serverCases defaulting to [] while server fetch is in flight, and ensure merged cases recompute when server cases refresh (e.g., by invalidating the merged query when serverCases changes). Expose server loading/error and a retry/refetch function for UI retry handling."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Allow local cases to render immediately while server-cases are loading/errored, preventing indefinite spinner after local case creation.",
      "acceptanceCriteria": [
        "Creating a new case shows the new CaseCard in the grid immediately after the modal closes (without waiting for the server-cases query to finish).",
        "`CaseList` only shows the centered spinning loader when there is genuinely no merged/local data to show yet; it does not block rendering solely because the server-cases query is loading.",
        "If there are local cases present, `CaseList` renders them even when backend connectivity is degraded, while still allowing the existing troubleshooting banner to appear when appropriate."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useCasesStore.ts",
          "operation": "modify",
          "description": "Refactor loading state so local persistence/merged data is available immediately (e.g., run merged cases query without waiting for server query; use local storage as initial/primary source). Return separate flags for 'hasAnyCases' vs 'server is loading' so UI can avoid blocking render when local cases exist."
        },
        {
          "path": "frontend/src/components/cases/CaseList.tsx",
          "operation": "modify",
          "description": "Adjust CaseList rendering logic to avoid showing the centered spinner solely due to server-cases loading. Show the spinner only when there is no merged/local case data to display yet; otherwise render the grid with available cases even if server fetch is still loading or has errored. Keep existing empty-state behavior for the true empty list case."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Show clear English error messaging when server case loading fails and provide a Retry action without blocking local-case viewing.",
      "acceptanceCriteria": [
        "When the server-cases fetch fails, the UI shows a readable error state for case loading (in English) instead of an endless spinner.",
        "The error state provides a Retry action that re-attempts fetching server cases (and subsequently recomputes merged cases).",
        "The error state does not prevent viewing any already-available local cases."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/cases/ServerCasesLoadError.tsx",
          "operation": "create",
          "description": "Create a small, user-facing error banner/card component for server case loading failures using existing composed UI components (e.g., Alert + Button) and clear English copy. Include a Retry button and optional 'details' hint. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/cases/CaseList.tsx",
          "operation": "modify",
          "description": "Wire the new ServerCasesLoadError component into CaseList: when server-cases fetch errors, show the error UI (with Retry calling the store's refetch/retry) while still rendering any available cases. Use classifyBackendError from frontend/src/utils/backendErrorMessages.ts to show a friendly message, and keep logging of the raw error in the query layer."
        },
        {
          "path": "frontend/src/hooks/useCasesStore.ts",
          "operation": "modify",
          "description": "Expose server-cases error state (raw and/or classified) and a retry/refetch function (from React Query) so CaseList can render the error state and retry server loading, triggering merged-case recomputation afterward."
        }
      ]
    }
  ]
}